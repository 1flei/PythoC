"""
Closure Adapter - Bridges closure calls with universal kernel

Pure AST adapter - generates AST only, no IR/builder operations.
Handles captured variables from outer scopes.
"""

import ast
from typing import Dict, Optional, Any, TYPE_CHECKING
from .kernel import InlineKernel
from .exit_rules import ReturnExitRule
from .scope_analyzer import ScopeContext
from ..valueref import ValueRef, wrap_value
from ..context import VariableInfo
from ..logger import logger
from ..utils import get_next_id

if TYPE_CHECKING:
    from ..ast_visitor.visitor_impl import LLVMIRVisitor


class ClosureAdapter:
    """
    Adapter for closure inlining using universal kernel
    
    Strategy (same as InlineAdapter):
    1. Create temporary variables for arguments
    2. Use kernel to transform closure AST (kernel detects captures automatically)
    3. Return pure AST for visitor to process
    
    The kernel's ScopeAnalyzer automatically detects captured variables.
    """
    
    def __init__(self, parent_visitor: 'LLVMIRVisitor', param_bindings: Dict[str, Any]):
        """
        Initialize closure adapter
        
        Args:
            parent_visitor: The visitor that's calling the closure
            param_bindings: Dict mapping parameter names to ValueRefs or Python objects
        """
        self.visitor = parent_visitor
        self.param_bindings = param_bindings
        self.kernel = InlineKernel()
    
    
    def execute_closure(self, func_ast: ast.FunctionDef) -> Optional[ValueRef]:
        """
        Execute closure inline using universal kernel
        
        Args:
            func_ast: The closure function AST to execute inline
            
        Returns:
            ValueRef of the return value, or None if no return
        """
        logger.debug(f"ClosureAdapter: executing closure inline for {func_ast.name}")
        
        # Determine result and flag variable names using global ID
        unique_id = get_next_id()
        result_var = f"_closure_result_{unique_id}"
        flag_var = f"_is_return_inline_{unique_id}"
        
        # Create exit rule
        exit_rule = ReturnExitRule(result_var=result_var, flag_var=flag_var)
        
        # Create temporary variables for arguments and register them
        arg_temps = self._create_arg_temps()
        
        # Create AST argument expressions (Name nodes referencing temp vars)
        arg_exprs = [ast.Name(id=temp_name, ctx=ast.Load()) for temp_name in arg_temps.values()]
        
        # Build caller context from current scope (for capture detection)
        caller_context = self._build_caller_context()
        
        # Create dummy call site
        call_site = ast.Call(
            func=ast.Name(id=func_ast.name, ctx=ast.Load()),
            args=arg_exprs,
            keywords=[]
        )
        
        # Create inline operation (kernel will detect captures)
        try:
            inline_op = self.kernel.create_inline_op(
                callee_func=func_ast,
                call_site=call_site,
                call_args=arg_exprs,
                caller_context=caller_context,
                exit_rule=exit_rule
            )
            
            # Log captured variables for debugging
            if inline_op.captured_vars:
                logger.debug(f"Closure captures: {inline_op.captured_vars}")
            
        except Exception as e:
            logger.error(f"ClosureAdapter: failed to create inline op: {e}")
            raise
        
        # Execute inline transformation
        try:
            inlined_stmts = self.kernel.execute_inline(inline_op)
        except Exception as e:
            logger.error(f"ClosureAdapter: kernel execution failed: {e}")
            raise
        
        # Fix AST locations
        for stmt in inlined_stmts:
            ast.fix_missing_locations(stmt)
        
        # Visit all statements generated by kernel
        # Kernel already generated:
        # 1. Parameter bindings: a = _arg_closure_1_0, b = _arg_closure_1_1
        # 2. Result declaration: _result: RetType (if has return)
        # 3. Flag declaration: _flag: bool = False
        # 4. Wrapped body in while True with transformed returns
        for stmt in inlined_stmts:
            self.visitor.visit(stmt)
        
        # Return result if function has return value
        has_return = self._has_return_value(func_ast)
        if has_return:
            return self._lookup_result_var(result_var)
        
        return None
    
    def _create_arg_temps(self) -> Dict[str, str]:
        """
        Create temporary variables for arguments and register in visitor scope
        
        Returns:
            Mapping of parameter names to temporary variable names
            
        IMPORTANT: These temps have NO alloca - they are pure value references.
        """
        arg_temps = {}
        closure_id = get_next_id()
        
        for i, (param_name, param_value) in enumerate(self.param_bindings.items()):
            # Create unique temp variable name
            temp_name = f"_arg_closure_{closure_id}_{i}"
            arg_temps[param_name] = temp_name
            
            # Wrap non-ValueRef as python ValueRef
            if not isinstance(param_value, ValueRef):
                from ..builtin_entities.python_type import PythonType
                param_value = wrap_value(param_value, kind="python",
                                     type_hint=PythonType.wrap(param_value, is_constant=True))
            
            # Register temp variable WITHOUT alloca
            temp_info = VariableInfo(
                name=temp_name,
                value_ref=param_value,
                alloca=None,  # CRITICAL: No alloca!
                source="closure_arg_temp",
                is_parameter=False
            )
            self.visitor.ctx.var_registry.declare(temp_info, allow_shadow=True)
            logger.debug(f"Created arg temp: {temp_name} for parameter {param_name}")
        
        return arg_temps
    
    def _build_caller_context(self) -> ScopeContext:
        """
        Build caller scope context for kernel
        
        This tells the kernel what variables are available in outer scope,
        so it can correctly identify captured variables.
        """
        available_vars = set()
        
        # Get all variables from visitor's registry
        if hasattr(self.visitor, 'ctx') and hasattr(self.visitor.ctx, 'var_registry'):
            registry = self.visitor.ctx.var_registry
            for var_info in registry.get_all_in_current_scope():
                available_vars.add(var_info.name)
        
        return ScopeContext(available_vars=available_vars)
    
    def _has_return_value(self, func_ast: ast.FunctionDef) -> bool:
        """Check if function has return statements with values"""
        for node in ast.walk(func_ast):
            if isinstance(node, ast.Return) and node.value is not None:
                return True
        return False
    
    def _lookup_result_var(self, var_name: str) -> Optional[ValueRef]:
        """Look up result variable and load its value"""
        var_info = self.visitor.ctx.var_registry.lookup(var_name)
        if not var_info:
            logger.warning(f"Result variable {var_name} not found")
            return None
        
        # Load the value from the alloca
        alloca = var_info.alloca
        loaded_value = self.visitor.builder.load(alloca)
        return wrap_value(loaded_value, kind='value', type_hint=var_info.type_hint)

